<!-- -*- text -*- -->
<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        
        <title>Unicode in the C++ Standard</title>
        
        <link rel="stylesheet" href="reveal.js/dist/reset.css">
        <link rel="stylesheet" href="reveal.js/dist/reveal.css">
        <link rel="stylesheet" href="reveal.js/dist/theme/black.css">
        
        <!-- Theme used for syntax highlighted code -->
        <link rel="stylesheet" href="reveal.js/plugin/highlight/monokai.css">
    </head>
    <body>
        <div class="reveal">
        <div class="slides">
            <section data-markdown=""
                     data-separator="^====+$"
                     data-separator-vertical="^----+$"
                     data-notes="^Note:">
              <script type="text/template">
## Applying the Lessons of `std::ranges` to Unicode in the Standard Library
### Zach Laine

----

### Why Unicode?

----

C and C++ are the only major production languages in the world without
first-class support for Unicode in their standard libraries.

Unicode support is essential for anyone that wants to support multiple
languages, some of which they may know nothing about.
<!-- .element: class="fragment" -->

Ask any English speaker to try capitalizing modern Greek without help.
<!-- .element: class="fragment" -->

----

### Some Terminology

----

A code point is a Unicode "character".  This may be a letter, number,
ideogram, or a combining mark like an accent.

A code unit is a unit of work, usually in one of the UTF encodings.  For
instance, a `char` might be a UTF-8 code unit, and a `wchar_t` on MSVC may be
a UTF-16 code unit.  Multiple code units encode a code point.
<!-- .element: class="fragment" -->

An extended grapheme cluster ("grapheme") is what the end-user sees as a
single symbol.  This might be a letter, a letter with an accent, a number, an
ideogram, an emoji, etc.
<!-- .element: class="fragment" -->

----

The industry standard for Unicode in C and C++ is, and has been for years, ICU.

----

ICU has no support for generic programming.  It uses fixed types for code
units and strings.

If you have a different string type in your code, including `std::string`, you
must make a copy to use the ICU string APIs.
<!-- .element: class="fragment" -->

----

Lack of generic programming support is directly at odds with the way the C++
standard library works.

----

<!-- See https://github.com/unicode-org/icu/blob/main/icu4c/source/samples/ustring/ustring.cpp#L300 -->

From the ICU samples:

```c++
static const char16_t input[] = /*...*/;
char16_t buffer[32];

UErrorCode errorCode = U_ZERO_ERROR;
int32_t length =
    u_strToLower(buffer, UPRV_LENGTHOF(buffer), input, -1,
                 "en", &errorCode);
if (U_SUCCESS(errorCode)) {
    // Use it.
} else {
    // Report error.
}
```

----

What we might standardize:

```c++
std::string text = "ijssel";

my_string lower;
std::uc::to_lower(text, std::inserter(lower, lower.end()));
assert(lower == my_string("Ijssel"));
```

This is C++ standard-style generic -- iterator-based and range-friendly.
<!-- .element: class="fragment" -->

----

### Design Considerations

----

Iterators are important. We should support generic programming, whether it is
done in terms of pointers, a particular iterator, or an iterator type
specified as a template parameter.

Ranges are also important. We should have range-friendly ways of doing
transcoding. This includes support for sentinels and lazy views.
<!-- .element: class="fragment" -->

----

A null-terminated string should not be treated as a special case. The ubiquity
of such strings means that they should be treated as first-class strings.

```c++
char const * text = "text";
auto utf16 = std::uc::as_utf16(text);

// Not:
// std::uc::as_utf16(
//   std::uc::utf8_view{text, std::uc::null_terminator});
```

----

Transcoding cannot be a black box; sometimes you need to be able to find where
there is a break in the encoding, or to detect whether a sequence has any
broken encodings in it. We should provide utility functions that let users
investigate these states.

----

It is common to want to view the same text as code points and code units at
different times. It is therefore important that Unicode-aware iterators have a
convenient way to access the underlying sequence of code units being
transcoded.

```c++
auto grs = std::uc::as_graphemes("text");

auto grs_first =         grs.begin();
auto grs_last =          grs.end();
auto code_points_first = grs.begin().base();
auto code_points_last =  grs.end().base();
auto code_units_first =  grs.begin().base().base();
auto code_units_last =   grs.end().base().base();
```

----

If thereâ€™s a specific algorithm specialization that operates directly on UTF-8
or UTF-16, the top-level algorithm should use that when appropriate. This is
analogous to having multiple implementations of the algorithms in std that
differ based on iterator category.

----

Input may come from UTF-8, UTF-16, or UTF-32 strings (though UTF-32 is
extremely uncommon in practice). There should be a single overload of each
normalization function, so that the user does not need to change code when the
input is changed from UTF-N to UTF-M. The most optimal version of the
algorithm (processing either UTF-8 or UTF-16) will be selected (as mentioned
just previously).


```c++
std::string text = "ijssel";

my_string lower;
std::uc::to_lower(text, std::inserter(lower, lower.end()));
assert(lower == my_string("Ijssel"));
```
<!-- .element: class="fragment" -->

----

UTF-8 is very important. We expect that the vast majority of users will keep
their text data in UTF-8 the vast majority of the time. It is compact, it is a
superset of ASCII, and it is in widespread use.

Graphemes are also very important. By having C++ users operate on text using
graphemes as their unit of work (as opposed to code points or code units),
they are less likely to mutate text in such a way that reader-perceived text
appears broken.
<!-- .element: class="fragment" -->

----

### Design

----

### `std::iterator_interface`

This very useful for reducing the amount of implementation and specification
time needed to produce iterators and views built from those iterators.

See P2727 and the Boost.STLInterfces CppCon talk for details.
<!-- .element: class="fragment" -->

----

### Transcoding

I consider the ability to convert among UTF-8 -16 and -32 to be table stakes
for any Unicode library.  It's not terribly intereseting, but it needs to be
done well, and to be convenient.

You can track the progress of committee paper P2728 to keep up with this work.

----

### Transcoding views

```c++
wchar_t const * utf16_text = /* ... */;

for (auto code_unit: utf16_text | std::uc::as_utf8) {
    // Use code_unit ...
}
```

```c++
for (auto code_point: utf16_text | std::uc::as_utf32) {
    // Use code_point ...
}
```
<!-- .element: class="fragment" -->

This is an example of a null-terminated string being treated as a range.
<!-- .element: class="fragment" -->

The loops would work the same if `utf16_text` were a `std::wstring`.
<!-- .element: class="fragment" -->

----

Views are easy to use and lazy.  They also compose nicely with the other `std`
views.

However, they do leave substantial performance on the table (2-3x, depending
on whether you use SIMD).  Even so, SG-16 has voted to remove the algorithms
from P2728, leaving only the views, reasoning that most strings will be short
enough that perf is not a first-order concern.
<!-- .element: class="fragment" -->

----

As with most `std` views, all the interesting work is done in the iterators.
Those are also available for direct use.

```c++
uint32_t const utf32[] = { ... };
char const utf8[] = { ... };
int i = 0;
for (auto it = std::uc::utf32_iterator(
              utf8, utf8, std::end(utf8)),
          end = std::uc::utf32_iterator(
              utf8, std::end(utf8), std::end(utf8));
     it != end; ++it) {
    assert(*it == utf32[i++]);
}
```

----

Each trancoding iterator contains three iterators (or two iterators and a
sentinel).

This is not about memory safety, but about correctness.
<!-- .element: class="fragment" -->

----

## Questions?

<span class="fragment fade-in">
https://github.com/tzlaine/text <br>
</span>

            </script>
            </section>
        </div>
    </div>

    <script src="reveal.js/dist/reveal.js"></script>
    <script src="reveal.js/plugin/notes/notes.js"></script>
    <script src="reveal.js/plugin/markdown/markdown.js"></script>
    <script src="reveal.js/plugin/highlight/highlight.js"></script>
    <script>
        // More info about initialization & config:
        // - https://revealjs.com/initialization/
        // - https://revealjs.com/config/
        Reveal.initialize({
            hash: true,
            // Learn about plugins: https://revealjs.com/plugins/
            plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
        });
    </script>
    </body>
</html>
